rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isTeamMember(teamData) {
      return (teamData.members != null &&
              teamData.members.hasAny([{'userId': request.auth.uid}])) ||
             (teamData.memberIds != null &&
              request.auth.uid in teamData.memberIds);
    }

    function isTeamOwnerOrCaptain(teamData) {
      return teamData.ownerId == request.auth.uid ||
             (teamData.members != null &&
              teamData.members.hasAny([
                {'userId': request.auth.uid, 'role': 'owner'},
                {'userId': request.auth.uid, 'role': 'captain'}
              ]));
    }

    function isTournamentOrganizer(tournamentData) {
      return tournamentData.organizerId == request.auth.uid;
    }

    function isVenueOwner(venueData) {
      return venueData.ownerId == request.auth.uid;
    }

    // ========== VENUE-RELATED RULES (NEW) ==========

    // Venues collection rules
    match /venues/{venueId} {
      // Allow anyone to read venues (for browsing and searching)
      allow read: if true;

      // Allow authenticated users to create venues
      allow create: if isAuthenticated() &&
                       request.resource.data.ownerId == request.auth.uid &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.isActive == true &&
                       request.resource.data.averageRating == 0.0 &&
                       request.resource.data.totalBookings == 0 &&
                       request.resource.data.totalReviews == 0;

      // Allow venue owners to update their venues
      allow update: if isAuthenticated() &&
                       isVenueOwner(resource.data) &&
                       request.resource.data.updatedAt == request.time &&
                       // Prevent changing owner
                       request.resource.data.ownerId == resource.data.ownerId;

      // Allow venue owners to delete their venues (soft delete by setting isActive = false)
      allow delete: if isAuthenticated() &&
                       isVenueOwner(resource.data);
    }

    // Venue bookings collection rules
    match /venue_bookings/{bookingId} {
      // Allow authenticated users to read bookings (needed for time slot availability checking)
      // Users can see booking status to check availability, but sensitive data is limited
      allow read: if isAuthenticated();

      // Allow authenticated users to create bookings
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.status == 'pending' &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time;

      // Allow users and venue owners to update booking status
      allow update: if isAuthenticated() &&
                       (resource.data.userId == request.auth.uid ||
                        resource.data.venueOwnerId == request.auth.uid) &&
                       request.resource.data.updatedAt == request.time;
    }

    // Venue reviews collection rules
    match /venue_reviews/{reviewId} {
      // Allow anyone to read reviews
      allow read: if true;

      // Allow authenticated users to create reviews
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.createdAt == request.time;

      // Allow review authors to update their reviews
      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;

      // Allow review authors to delete their reviews
      allow delete: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;
    }

    // Notifications collection rules
    match /notifications/{notificationId} {
      // Allow users to read their own notifications
      allow read: if isAuthenticated() &&
                     resource.data.userId == request.auth.uid;

      // Allow system/authenticated users to create notifications
      allow create: if isAuthenticated();

      // Allow users to update their own notifications (mark as read, etc.)
      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;

      // Allow users to delete their own notifications
      allow delete: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;
    }

    // ========== RATING SYSTEM RULES ==========

    // Ratings collection rules
    match /ratings/{ratingId} {
      // Allow anyone to read ratings (for displaying on profiles/listings)
      allow read: if true;

      // Allow authenticated users to create ratings only if they are the rater
      allow create: if isAuthenticated() &&
                       request.resource.data.ratedBy == request.auth.uid &&
                       request.resource.data.timestamp == request.time;

      // Prevent updates to existing ratings (ratings are immutable)
      allow update: if false;

      // Allow rating authors to delete their own ratings (if needed)
      allow delete: if isAuthenticated() &&
                       resource.data.ratedBy == request.auth.uid;
    }

    // Rating statistics collection rules
    match /rating_stats/{entityId} {
      // Allow anyone to read rating statistics
      allow read: if true;

      // Only allow system/service to create and update rating stats
      allow create, update: if isAuthenticated();

      // Prevent deletion of rating stats
      allow delete: if false;
    }

    // Pending ratings collection rules
    match /pending_ratings/{pendingRatingId} {
      // Allow users to read their own pending ratings
      allow read: if isAuthenticated() &&
                     resource.data.userId == request.auth.uid;

      // Allow system/service to create pending ratings
      allow create: if isAuthenticated();

      // Allow system/service to update pending ratings (mark as completed)
      allow update: if isAuthenticated();

      // Allow users to delete their own pending ratings
      allow delete: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;
    }

    // Listings collection rules (enhanced for ratings)
    match /listings/{listingId} {
      // Allow anyone to read listings
      allow read: if true;

      // Allow authenticated users to create listings
      allow create: if isAuthenticated() &&
                       request.resource.data.ownerId == request.auth.uid &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.isActive == true &&
                       request.resource.data.averageRating == 0.0 &&
                       request.resource.data.totalBookings == 0;

      // Allow listing owners to update their listings
      allow update: if isAuthenticated() &&
                       resource.data.ownerId == request.auth.uid &&
                       request.resource.data.updatedAt == request.time &&
                       // Prevent changing owner
                       request.resource.data.ownerId == resource.data.ownerId;

      // Allow listing owners to delete their listings
      allow delete: if isAuthenticated() &&
                       resource.data.ownerId == request.auth.uid;
    }

    // Bookings collection rules (enhanced for ratings)
    match /bookings/{bookingId} {
      // Allow users to read their own bookings and listing owners to read bookings for their listings
      allow read: if isAuthenticated() &&
                     (resource.data.userId == request.auth.uid ||
                      resource.data.ownerId == request.auth.uid);

      // Allow authenticated users to create bookings
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time;

      // Allow users and listing owners to update booking status
      allow update: if isAuthenticated() &&
                       (resource.data.userId == request.auth.uid ||
                        resource.data.ownerId == request.auth.uid) &&
                       request.resource.data.updatedAt == request.time;

      // Allow booking participants to delete bookings (cancellation)
      allow delete: if isAuthenticated() &&
                       (resource.data.userId == request.auth.uid ||
                        resource.data.ownerId == request.auth.uid);
    }

    // ========== CHAT SYSTEM RULES ==========

    // Helper function to check if user is a chat participant
    function isChatParticipant(chatData) {
      return chatData.participantIds != null &&
             request.auth.uid in chatData.participantIds;
    }


    // Helper function to check if user is involved in a connection
    function isConnectionParticipant(connectionData) {
      return connectionData.fromUserId == request.auth.uid ||
             connectionData.toUserId == request.auth.uid;
    }

    // Chats collection rules
    match /chats/{chatId} {
      // Allow read if user is a participant in the chat, for direct chats, or for team chats
      allow read: if isAuthenticated() &&
                     ((resource.data != null && isChatParticipant(resource.data)) ||
                      (chatId.matches('direct_.*') &&
                       (chatId.matches('direct_' + request.auth.uid + '_.*') ||
                        chatId.matches('direct_.*_' + request.auth.uid))) ||
                      // Allow team chat access if user is team member
                      (chatId.matches('team_.*') &&
                       exists(/databases/$(database)/documents/teams/$(chatId.split('_')[1])) &&
                       isTeamMember(get(/databases/$(database)/documents/teams/$(chatId.split('_')[1])).data)));

      // Allow create if authenticated and user is a participant or for team chats
      allow create: if isAuthenticated() &&
                       ((request.resource.data.participantIds != null &&
                         request.auth.uid in request.resource.data.participantIds) ||
                        // Allow team chat creation by team members
                        (chatId.matches('team_.*') &&
                         exists(/databases/$(database)/documents/teams/$(request.resource.data.entityId)) &&
                         isTeamMember(get(/databases/$(database)/documents/teams/$(request.resource.data.entityId)).data)));

      // Allow update if user is a participant or team member for team chats
      allow update: if isAuthenticated() &&
                       ((resource.data.participantIds != null &&
                         request.auth.uid in resource.data.participantIds) ||
                        // Allow team chat updates by team members
                        (chatId.matches('team_.*') &&
                         exists(/databases/$(database)/documents/teams/$(resource.data.entityId)) &&
                         isTeamMember(get(/databases/$(database)/documents/teams/$(resource.data.entityId)).data)));

      // Messages subcollection
      match /messages/{messageId} {
        // Allow read if user is a chat participant
        allow read: if isAuthenticated() &&
                       exists(/databases/$(database)/documents/chats/$(chatId)) &&
                       isChatParticipant(get(/databases/$(database)/documents/chats/$(chatId)).data);

        // Allow create if user is authenticated and is the sender
        allow create: if isAuthenticated() &&
                         request.resource.data.senderId == request.auth.uid &&
                         request.resource.data.chatId == chatId &&
                         request.resource.data.timestamp == request.time &&
                         exists(/databases/$(database)/documents/chats/$(chatId)) &&
                         isChatParticipant(get(/databases/$(database)/documents/chats/$(chatId)).data);

        // Allow update for marking messages as read
        allow update: if isAuthenticated() &&
                         exists(/databases/$(database)/documents/chats/$(chatId)) &&
                         isChatParticipant(get(/databases/$(database)/documents/chats/$(chatId)).data);

        // Allow delete if user is the sender (for message deletion)
        allow delete: if isAuthenticated() &&
                         resource.data.senderId == request.auth.uid;
      }
    }

    // Connections collection rules (for friend/connection requests)
    match /connections/{connectionId} {
      // Allow read if user is involved in the connection (sender or receiver)
      allow read: if isAuthenticated() && isConnectionParticipant(resource.data);

      // Allow create if authenticated and user is the sender
      allow create: if isAuthenticated() &&
                       request.resource.data.fromUserId == request.auth.uid &&
                       request.resource.data.status == 'pending' &&
                       request.resource.data.createdAt == request.time;

      // Allow update for status changes by receiver or cancellation by sender
      allow update: if isAuthenticated() &&
                       (
                         // Receiver can accept/reject
                         (resource.data.toUserId == request.auth.uid &&
                          request.resource.data.respondedAt == request.time) ||
                         // Sender can cancel
                         (resource.data.fromUserId == request.auth.uid &&
                          request.resource.data.status == 'cancelled' &&
                          request.resource.data.respondedAt == request.time)
                       );

      // Allow delete by either participant (for removing connections)
      allow delete: if isAuthenticated() && isConnectionParticipant(resource.data);
    }

    // ========== EXISTING RULES (UNCHANGED) ==========

    // Teams collection rules
    match /teams/{teamId} {
      // Allow authenticated users to read all active teams for search and discovery
      // This enables team search, browsing, and discovery features
      allow read: if isAuthenticated() &&
                     resource.data.isActive == true;

      // Allow create if authenticated and user is set as owner
      allow create: if isAuthenticated() &&
                       request.resource.data.ownerId == request.auth.uid &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.isActive == true;

      // Allow update if user is team owner, captain, or member (for various team operations)
      allow update: if isAuthenticated() &&
                       (resource.data.ownerId == request.auth.uid ||
                        isTeamOwnerOrCaptain(resource.data) ||
                        isTeamMember(resource.data)) &&
                       request.resource.data.updatedAt == request.time;

      // Allow delete (soft delete) if user is team owner
      allow delete: if isAuthenticated() &&
                       resource.data.ownerId == request.auth.uid;
    }

    // Team join requests collection rules
    match /team_join_requests/{requestId} {
      // Allow read if user is the requester or team owner/captain
      allow read: if isAuthenticated() &&
                     (resource.data.requesterId == request.auth.uid ||
                      exists(/databases/$(database)/documents/teams/$(resource.data.teamId)) &&
                      isTeamOwnerOrCaptain(get(/databases/$(database)/documents/teams/$(resource.data.teamId)).data));

      // Allow create if authenticated and user is the requester
      allow create: if isAuthenticated() &&
                       request.resource.data.requesterId == request.auth.uid &&
                       request.resource.data.status == 'pending' &&
                       request.resource.data.createdAt == request.time;

      // Allow update for status changes by team owner/captain or cancellation by requester
      allow update: if isAuthenticated() &&
                       (
                         // Team owner/captain can approve/reject
                         (exists(/databases/$(database)/documents/teams/$(resource.data.teamId)) &&
                          isTeamOwnerOrCaptain(get(/databases/$(database)/documents/teams/$(resource.data.teamId)).data) &&
                          request.resource.data.respondedBy == request.auth.uid &&
                          request.resource.data.respondedAt == request.time) ||
                         // Requester can cancel
                         (resource.data.requesterId == request.auth.uid &&
                          request.resource.data.status == 'cancelled' &&
                          request.resource.data.respondedAt == request.time)
                       );
    }

    // Captain voting collection rules
    match /captain_votes/{votingId} {
      // Allow team members to read voting for their team
      allow read: if isAuthenticated() &&
                     exists(/databases/$(database)/documents/teams/$(resource.data.teamId)) &&
                     isTeamMember(get(/databases/$(database)/documents/teams/$(resource.data.teamId)).data);

      // Allow team captains/owners to create voting
      allow create: if isAuthenticated() &&
                       exists(/databases/$(database)/documents/teams/$(request.resource.data.teamId)) &&
                       isTeamOwnerOrCaptain(get(/databases/$(database)/documents/teams/$(request.resource.data.teamId)).data) &&
                       request.resource.data.initiatedBy == request.auth.uid &&
                       request.resource.data.createdAt == request.time;

      // Allow team members to vote and system to update voting status
      allow update: if isAuthenticated() &&
                       exists(/databases/$(database)/documents/teams/$(resource.data.teamId)) &&
                       isTeamMember(get(/databases/$(database)/documents/teams/$(resource.data.teamId)).data);
    }

    // Tournaments collection rules
    match /tournaments/{tournamentId} {
      // Allow read if tournament is public or user is organizer
      allow read: if isAuthenticated() &&
                     (resource.data.isPublic == true ||
                      resource.data.organizerId == request.auth.uid);

      // Allow create if authenticated and user is set as organizer
      allow create: if isAuthenticated() &&
                       request.resource.data.organizerId == request.auth.uid &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.currentTeamsCount == 0;

      // Allow update if user is tournament organizer
      allow update: if isAuthenticated() &&
                       resource.data.organizerId == request.auth.uid &&
                       request.resource.data.updatedAt == request.time &&
                       // Prevent changing organizer
                       request.resource.data.organizerId == resource.data.organizerId;

      // Allow delete if user is tournament organizer
      allow delete: if isAuthenticated() &&
                       resource.data.organizerId == request.auth.uid;
    }

    // Tournament registrations collection rules
    match /tournament_registrations/{registrationId} {
      // Allow read if user registered the team, is tournament organizer, or is a team member
      allow read: if isAuthenticated() &&
                     (resource.data.registeredBy == request.auth.uid ||
                      exists(/databases/$(database)/documents/tournaments/$(resource.data.tournamentId)) &&
                      isTournamentOrganizer(get(/databases/$(database)/documents/tournaments/$(resource.data.tournamentId)).data) ||
                      // Allow team members to read registrations for their teams (for profile display)
                      (resource.data.teamMembers != null &&
                       resource.data.teamMembers.hasAny([request.auth.uid])));

      // Allow create if authenticated and user is registering
      allow create: if isAuthenticated() &&
                       request.resource.data.registeredBy == request.auth.uid &&
                       request.resource.data.status == 'pending' &&
                       request.resource.data.registeredAt == request.time;

      // Allow update for status changes by tournament organizer or withdrawal by registrant
      allow update: if isAuthenticated() &&
                       (
                         // Tournament organizer can approve/reject
                         (exists(/databases/$(database)/documents/tournaments/$(resource.data.tournamentId)) &&
                          isTournamentOrganizer(get(/databases/$(database)/documents/tournaments/$(resource.data.tournamentId)).data) &&
                          request.resource.data.respondedBy == request.auth.uid &&
                          request.resource.data.respondedAt == request.time) ||
                         // Registrant can withdraw
                         (resource.data.registeredBy == request.auth.uid &&
                          request.resource.data.status == 'withdrawn' &&
                          request.resource.data.respondedAt == request.time)
                       );
    }

    // User profiles - Updated to allow discovery while protecting sensitive data
    match /users/{userId} {
      // Allow authenticated users to read user profiles for discovery (players, coaches)
      // This enables features like finding players, matchmaking, team formation
      allow read: if isAuthenticated();

      // Only allow users to write to their own profile
      allow write: if isAuthenticated() && isOwner(userId);
    }

    // Player profiles (existing rules - keeping for reference)
    match /player_profiles/{userId} {
      allow read, write: if isAuthenticated() && isOwner(userId);
    }

    // Coach profiles (existing rules - keeping for reference)
    match /coach_profiles/{userId} {
      allow read, write: if isAuthenticated() && isOwner(userId);
    }

    // ========== SHOP: PRODUCTS ==========
    match /products/{productId} {
      // Anyone can browse products
      allow read: if true;

      // Only authenticated users can create products they own
      allow create: if isAuthenticated() &&
                     request.resource.data.ownerId == request.auth.uid &&
                     request.resource.data.createdAt == request.time;

      // Owners can update their products; prevent changing ownerId
      allow update: if isAuthenticated() &&
                     resource.data.ownerId == request.auth.uid &&
                     request.resource.data.ownerId == resource.data.ownerId;

      // Owners can delete their products
      allow delete: if isAuthenticated() && resource.data.ownerId == request.auth.uid;

      // Reviews subcollection
      match /reviews/{reviewId} {
        allow read: if true;
        allow create: if isAuthenticated() &&
                         request.resource.data.userId == request.auth.uid &&
                         request.resource.data.timestamp == request.time &&
                         exists(/databases/$(database)/documents/users/$(request.auth.uid)/purchases/$(productId));
        allow update, delete: if isAuthenticated() &&
                                resource.data.userId == request.auth.uid;
      }
    }

    // ========== SHOP: USER CART ==========
    match /users/{userId}/cart/{cartItemId} {
      // Only the owner can access their cart
      allow read, create, update, delete: if isAuthenticated() && isOwner(userId);
    }


    // ========== SHOP: USER PURCHASES (helper for review gating) ==========
    match /users/{userId}/purchases/{productId} {
      // Owner can read their purchases
      allow read: if isAuthenticated() && isOwner(userId);
      // Create only by owner; enforce timestamps
      allow create: if isAuthenticated() &&
                       isOwner(userId) &&
                       request.resource.data.productId == productId &&
                       request.resource.data.lastPurchasedAt == request.time;
      // Allow updates by owner to increment counts and refresh timestamp
      allow update: if isAuthenticated() &&
                       isOwner(userId) &&
                       request.resource.data.lastPurchasedAt == request.time;
      // Do not allow delete to preserve audit trail
      allow delete: if false;
    }

    // ========== SHOP: ORDERS ==========
    match /orders/{orderId} {
      // Users can read their own orders
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;

      // Users can create orders for themselves
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.orderDate == request.time;

      // Prevent updating/deleting orders after creation
      allow update, delete: if false;
    }

    // ========== USER STATS ==========
    match /user_stats/{userId} {
      // Users can read and write their own stats
      allow read, write: if isAuthenticated() && userId == request.auth.uid;
    }

    // ========== EVENTS ==========
    match /events/{eventId} {
      // Allow authenticated users to read public events
      allow read: if isAuthenticated() && resource.data.isPublic == true;

      // Allow authenticated users to create events
      allow create: if isAuthenticated() &&
                       request.resource.data.organizerId == request.auth.uid &&
                       request.resource.data.createdAt == request.time;

      // Allow event organizers to update their events
      allow update: if isAuthenticated() &&
                       resource.data.organizerId == request.auth.uid &&
                       request.resource.data.updatedAt == request.time;

      // Allow event organizers to delete their events
      allow delete: if isAuthenticated() &&
                       resource.data.organizerId == request.auth.uid;
    }

    // ========== SHOP PRODUCTS ==========
    match /shop_products/{productId} {
      // Allow authenticated users to read all products
      allow read: if isAuthenticated();

      // Only allow admins to write products (for now, no write access)
      allow write: if false;
    }

    // ========== PEOPLE MATCHING SYSTEM ==========

    // User swipes collection rules (for tracking likes/passes)
    match /user_swipes/{swipeId} {
      // Allow users to read their own swipes
      allow read: if isAuthenticated() &&
                     resource.data.fromUserId == request.auth.uid;

      // Allow users to create their own swipes
      allow create: if isAuthenticated() &&
                       request.resource.data.fromUserId == request.auth.uid &&
                       request.resource.data.createdAt == request.time;

      // Prevent updates and deletes (swipes are immutable)
      allow update, delete: if false;
    }

    // User matches collection rules (for mutual likes)
    match /user_matches/{matchId} {
      // Allow users to read matches they are part of
      allow read: if isAuthenticated() &&
                     (resource.data.user1Id == request.auth.uid ||
                      resource.data.user2Id == request.auth.uid);

      // Allow system to create matches (when mutual like is detected)
      allow create: if isAuthenticated() &&
                       (request.resource.data.user1Id == request.auth.uid ||
                        request.resource.data.user2Id == request.auth.uid) &&
                       request.resource.data.createdAt == request.time;

      // Allow users to update match status (e.g., expire matches)
      allow update: if isAuthenticated() &&
                       (resource.data.user1Id == request.auth.uid ||
                        resource.data.user2Id == request.auth.uid);

      // Prevent deletion of matches (for audit trail)
      allow delete: if false;
    }

    // Profile comments collection rules
    match /profile_comments/{commentId} {
      // Allow users to read comments on their own profile
      allow read: if isAuthenticated() &&
                     resource.data.toUserId == request.auth.uid;

      // Allow users to create comments
      allow create: if isAuthenticated() &&
                       request.resource.data.fromUserId == request.auth.uid &&
                       request.resource.data.createdAt == request.time;

      // Allow comment authors to update their comments
      allow update: if isAuthenticated() &&
                       resource.data.fromUserId == request.auth.uid;

      // Allow comment authors to delete their comments
      allow delete: if isAuthenticated() &&
                       resource.data.fromUserId == request.auth.uid;
    }

    // Daily moods collection rules
    match /daily_moods/{moodId} {
      // Allow users to read their own moods and others' moods for discovery
      allow read: if isAuthenticated();

      // Allow users to create/update their own daily mood
      allow create, update: if isAuthenticated() &&
                               request.resource.data.userId == request.auth.uid &&
                               request.resource.data.createdAt == request.time;

      // Allow users to delete their own moods
      allow delete: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;
    }
  }
}

